МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»





ЗВІТ
з лабораторної роботи 3
з дисципліни «Аналіз та рефакторінг коду»
на тему «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»



Виконав:
ст. гр. ПЗПІ-23-7
Максименко М.В.


Перевірив: Викладач Дашенков Д.С.





Харків 2025




1 ОПИС ІНЖЕНЕРНИХ РІШЕНЬ
1.1 Архітектурні рішення
Під час розробки серверної частини програмної системи аналізу та догляду за шкірою було обрано багатошарову архітектуру типу API – Бізнес-логіка – Доступ до даних. Такий підхід чітко розділяє відповідальність між обробкою HTTP-запитів, реалізацією правил предметної області та роботою з базою даних, що спрощує супровід і подальший розвиток системи.
Основні шари серверної частини:
• API-рівень (Controllers) – відповідає за прийом HTTP-запитів від клієнтів, базову валідацію даних та формування HTTP-відповідей у форматі JSON. На цьому рівні реалізовані контролери:
o userController – реєстрація та авторизація користувачів, отримання й оновлення їх профілю;
o skinController – створення й редагування описів стану шкіри;
o analysisController – управління аналізами шкіри;
o skinAnalysisRecordController – ведення записів умов проведення аналізів;
o treatmentController – створення та керування курсами лікування/догляду.
• Шар бізнес-логіки – реалізований всередині контролерів та допоміжних модулів. Він містить основні правила предметної області догляду за шкірою: зв’язок користувача зі станами шкіри, обмеження на створення аналізів лише для існуючих записів Skin, прив’язку курсів лікування до конкретного користувача, перевірки доступу на основі токена та прапорця is_admin тощо. На цьому рівні приймаються рішення «можна / не можна» виконувати певну операцію, а також формується послідовність викликів до БД.
• Шар доступу до даних (Models / ORM) – інкапсулює роботу з реляційною базою даних через ORM-бібліотеку. Для кожної сутності (User, Skin, Analysis, SkinAnalysisRecord, Treatment) створено окрему модель із визначенням полів, типів даних і зв’язків (foreign key). Контролери не працюють із SQL-запитами напряму, а викликають методи ORM (create, findByPk, findAll, save, destroy), що знижує ризик помилок і спрощує зміну структури БД.
Для розмежування доступу використовується middleware-рівень:
• authMiddleware витягує ідентифікатор користувача з JWT-токена, який зберігається в cookie, і підставляє його в req.user_id;
• додатковий middleware перевіряє прапорець is_admin для операцій, доступних лише косметологам / адміністраторам (наприклад, масовий перегляд користувачів чи створення аналізів).
Взаємодія шарів відбувається за такою схемою:
1. Клієнт (веб-інтерфейс або мобільний застосунок) надсилає HTTP-запит до відповідного ендпоінта REST-API.
2. Маршрут Express передає запит контролеру, застосовуючи необхідні middleware для авторизації.
3. Контролер виконує бізнес-перевірки (наявність користувача, коректність полів, відповідність зв’язків user_id, skin_id, analysis_id) і звертається до ORM-моделей.
4. ORM виконує запити до БД, формує об’єкти доменної моделі та повертає їх контролеру.
5. Контролер формує JSON-відповідь і повертає її клієнту.
Такий підхід дозволяє відокремити бізнес-логіку догляду за шкірою від деталей зберігання даних, а також безболісно розширювати систему новими модулями (наприклад, модулем рекомендацій чи автоматичного імпорту даних з IoT-пристроїв).

1.2 Вибір технологій та інструментів
Для реалізації серверної частини системи було обрано стек технологій на базі JavaScript і Node.js, що дозволяє використовувати одну мову як на клієнтському, так і на серверному боці.
Основні технології:
• Node.js + Express
Express виступає мінімалістичним веб-фреймворком для побудови REST-API. Він надає зручний механізм маршрутизації, підтримку middleware для авторизації, логування й обробки помилок. Це дозволяє легко описати ендпоінти типу /api/skin, /api/analysis, /api/treatment та централізовано обробляти винятки.
• ORM-моделі (Sequelize)
Для роботи з реляційною базою даних застосовується ORM, яка відображає таблиці User, Skin, Analysis, SkinAnalysisRecord, Treatment у відповідні JavaScript-класи. Це дає змогу працювати з даними на рівні об’єктів, а не сирих SQL-запитів, та спрощує міграції й еволюцію схеми БД.
• Реляційна СУБД (PostgreSQL)
Обрана СУБД підтримує зовнішні ключі, індекси та транзакції, що важливо для зберігання пов’язаних даних про користувачів, стани шкіри, аналізи та лікування. Структура БД побудована згідно з ER-діаграмою і передбачає зв’язки 1:N між User і Skin, Skin і Analysis, Analysis і SkinAnalysisRecord, User і Treatment.
• JWT (JSON Web Token)
Для автентифікації користувачів використовується JWT. Після успішного входу (/api/login) сервер генерує токен із ідентифікатором користувача і зберігає його в cookie. Подальші запити проходять через middleware, яке перевіряє валідність токена і встановлює req.user_id. Це дозволяє керувати доступом без збереження сесій на сервері.
• bcrypt для хешування паролів
Паролі користувачів ніколи не зберігаються у відкритому вигляді. Модуль passwordHasher виконує хешування під час реєстрації та порівняння пароля під час входу.
• Postman 
Для тестування REST-API та документування ендпоінтів можуть використовуватися інструменти Postman. Вони дозволяють перевіряти запити до /api/skin, /api/analysis, /api/treatment та відразу бачити структуру JSON-відповідей.
Обраний стек технологій забезпечує легку інтеграцію з фронтендом, гнучку роботу з моделями БД та можливість масштабування проєкту в майбутньому (додавання мобільних клієнтів, IoT-пристроїв, нових типів аналізів шкіри тощо).

1.3 Реалізована бізнес-логіка
Бізнес-логіка системи аналізу та догляду за шкірою побудована навколо таких основних процесів:
1. Управління користувачами та ролями.
Система дозволяє реєструвати нових користувачів, хешувати їх паролі та виконувати авторизацію на основі email + пароль. Частина користувачів може мати розширені права (косметологи / адміністратори), що визначається прапорцем is_admin у моделі User.
Ключові функції:
o створення користувача (register / createUser) та автоматичний вхід після реєстрації;
o вхід у систему (login) із перевіркою пароля та видачею JWT-токена;
o отримання інформації про поточного користувача за токеном (getUserByToken);
o перегляд, оновлення та видалення користувачів (із додатковими перевірками прав доступу).
2. Ведення «карти шкіри» користувача.
Для кожного користувача косметолог або сам користувач може створювати описи стану шкіри (модель Skin). Це може бути початковий стан перед лікуванням, проміжний стан або результат після курсу.
Операції:
o створення опису стану шкіри (createSkin);
o перегляд одного або всіх станів шкіри (getSkinById, getAllSkins);
o оновлення й видалення записів (updateSkin, deleteSkin).
3. Проведення та зберігання аналізів шкіри.
На основі запису Skin проводяться аналізи (апаратні, візуальні, комбіновані), які зберігаються в моделі Analysis.
Операції:
o створення аналізу для конкретного стану шкіри (createAnalysis);
o перегляд окремого аналізу та списку всіх аналізів (getAnalysisById, getAllAnalyses);
o оновлення результатів аналізу та його видалення (updateAnalysis, deleteAnalysis).
4. Фіксація умов проведення аналізів.
Окремо ведуться записи SkinAnalysisRecord, які описують контекст аналізу: «до початку лікування», «через 7 днів», «після двох тижнів застосування крему» тощо.
Операції:
o створення запису умов (createSkinAnalysisRecord);
o перегляд, оновлення та видалення записів (getSkinAnalysisRecordById, getAllSkinAnalysisRecords, updateSkinAnalysisRecord, deleteSkinAnalysisRecord).
5. Призначення та супровід курсів лікування.
Для користувача створюються курси лікування або догляду (модель Treatment), які мають тип, дати початку та завершення. На основі цих даних система дозволяє відстежувати, які процедури коли проводилися, та зіставляти їх із результатами аналізів.
Операції:
o створення курсу лікування (createTreatment);
o перегляд окремого курсу або всього списку курсів (getTreatmentById, getAllTreatments);
o оновлення параметрів курсу (updateTreatment);
o видалення курсу (deleteTreatment).
6. Контроль доступу та узгодженість даних.
Усі «чутливі» операції виконуються тільки для авторизованих користувачів. Коли йдеться про масове керування даними (наприклад, перегляд усіх користувачів чи створення аналізу іншій людині), застосовується додаткова перевірка is_admin.
При створенні аналізів, записів умов та курсів лікування бізнес-логіка перевіряє існування відповідних сутностей (user_id, skin_id, analysis_id) і коректність зв’язків, що запобігає появі «висячих» посилань у БД.
У результаті серверна частина не просто виконує CRUD-операції, а реалізує реальний бізнес-процес: від первинного опису шкіри через послідовні аналізи до призначення й оцінки ефективності курсів лікування.

1.4 Функції адміністрування
Функції адміністрування в системі аналізу та догляду за шкірою забезпечують централізоване керування користувачами, записами про стан шкіри, аналізами та курсами лікування. На відміну від окремого «адмінського» модуля, роль адміністратора/косметолога визначається полем is_admin у моделі User, а контроль доступу здійснюється через middleware.
Основні можливості користувачів із розширеними правами (is_admin = true):
1. Керування користувачами.
Косметолог/адміністратор може переглядати список усіх користувачів (ендпоінт GET /api/users), відкривати деталі конкретного профілю, за потреби оновлювати контактні дані або видаляти облікові записи, які більше не використовуються. При цьому паролі ніколи не повертаються у відповідях: контролер видаляє поле password перед відправкою даних клієнту.
2. Створення та редагування медичних записів.
Лише спеціаліст із прапорцем is_admin має право:
o створювати та оновлювати описи стану шкіри користувачів (POST /api/skin, PUT /api/skin/:id);
o створювати аналізи шкіри (POST /api/analysis) та записувати результати;
o додавати записи умов проведення аналізу (POST /api/record);
o призначати курси лікування/догляду (POST /api/treatment).
Це відображає реальну практику: офіційні висновки та призначення робить саме фахівець, а не звичайний користувач.
3. Перегляд узагальненої інформації по пацієнтах.
Адміністратор/косметолог може отримувати списки станів шкіри, аналізів, записів умов і курсів лікування в розрізі користувачів. Це дозволяє порівнювати ефективність різних схем догляду, швидко знаходити останні аналізи та контролювати, чи дотримується пацієнт рекомендацій.
4. Підтримка цілісності даних.
Адміністративні операції реалізують додаткові перевірки, щоб не виникало ситуацій, коли:
o створюється аналіз для неіснуючого стану шкіри;
o призначається курс лікування для користувача, якого немає в БД;
o видаляються записи, що є критично важливими для історії лікування.
Завдяки цьому адміністратор не тільки «бачить все», а й не може випадково порушити цілісність бази даних.
У комплексі ці функції адміністрування роблять систему придатною для реальної роботи косметологічного кабінету або онлайн-сервісу догляду за шкірою: спеціалісти мають повний контроль над даними, а користувачі – зручний доступ до власної історії стану шкіри та лікування.

2 ФРАГМЕНТИ ПРОГРАМНОГО КОДУ
У цьому розділі наведено приклади основних частин бізнес-логіки серверної частини системи аналізу та догляду за шкірою.
2.1 Реалізація бізнес-логіки створення аналізу шкіри
Бізнес-логіка створення аналізу реалізована у контролері analysisController.js у вигляді методу createAnalysis. Метод отримує з тіла запиту тип аналізу, результат та ідентифікатор стану шкіри (skin_id), виконує створення нового запису в моделі Analysis і повертає клієнту створений об’єкт.
const { models } = require("../models");

const createAnalysis = async (req, res) => {
  const { analysis_type, result, skin_id } = req.body;
  try {
    const analysis = await models.Analysis.create({
      analysis_type,
      result,
      skin_id,
    });
    res.status(201).json(analysis);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};
Таким чином, навіть при простому інтерфейсі (форма «Тип аналізу» + «Результат») сервер гарантує, що для кожного аналізу буде збережено посилання на конкретний стан шкіри, а у разі помилки клієнт отримає структуровану відповідь із кодом 400.

2.2 Реалізація бізнес-логіки призначення курсу лікування
Бізнес-логіка призначення курсу лікування реалізована в treatmentController.js через метод createTreatment. Він приймає тип лікування та дати початку/завершення, а також ідентифікатор користувача, для якого призначається курс.
const { models } = require("../models");

const createTreatment = async (req, res) => {
  const { treatment_type, start_date, end_date, user_id } = req.body;
  try {
    const treatment = await models.Treatment.create({
      treatment_type,
      start_date,
      end_date,
      user_id,
    });
    res.status(201).json(treatment);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};
У результаті кожен курс лікування чітко прив’язаний до користувача (user_id), має часові межі та власний опис. Надалі ці дані використовуються для побудови історії лікування й аналізу ефективності призначень.

2.3 Отримання поточного користувача за токеном
Окремим елементом бізнес-логіки є можливість отримати дані поточного користувача за JWT-токеном, збереженим у cookie. Для цього використовується функція getUserByToken у userController.js, яка читає req.user_id, завантажує користувача з БД та повертає його дані без пароля.
const getUserByToken = async (req, res) => {
  const id = Number(req.user_id);

  try {
    const user = await models.User.findByPk(id);
    if (user) {
      const userWithoutPassword = { ...user.toJSON() };
      delete userWithoutPassword.password;

      res.json(userWithoutPassword);
    } else {
      res.status(404).json({ error: "User not found" });
    }
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};
Цей фрагмент демонструє, як серверна частина поєднує механізм авторизації (JWT + middleware) з бізнес-логікою роботи з профілем користувача та захистом чутливих даних (пароль не повертається клієнту).

3 UML ДІАГРАМИ
3.1 Діаграма діяльності процесу створення запису на огляд до лікаря

Рисунок 3.1 – UML-Діаграма створення запису на огляд до лікаря
На діаграмі діяльності показано основні кроки бізнес-процесу створення запису на огляд до лікаря (косметолога): від моменту надсилання HTTP-запиту клієнтським застосунком до успішного збереження запису в базі даних або повернення помилки у разі порушення бізнес-правил.
Послідовно виконуються перевірки обов’язкових полів (дата, час, ідентифікатор користувача, вибраний лікар/косметолог), перевірка існування користувача в системі, наявності лікаря з коректними правами (наприклад, прапорець is_admin або роль фахівця), а також відсутності конфліктів у розкладі лікаря на вибраний час. У разі невдачі на будь-якому етапі формується помилка з відповідним HTTP-кодом, яка повертається клієнту у форматі JSON. Якщо всі перевірки успішні, створюється новий запис на огляд, і система повертає клієнту підтвердження про успішне бронювання.

3.2 Діаграма послідовності обробки запиту створення запису на огляд до лікаря
Рисунок 3.2 – UML-Діаграма взаємодії
Діаграма послідовності деталізує взаємодію між основними учасниками процесу створення запису на огляд: клієнтським застосунком (веб- або мобільним інтерфейсом), сервером Express, маршрутизатором та контролером (наприклад, appointmentsController або відповідним методом серверної частини), шаром доступу до даних (ORM-моделями) та базою даних.
Показано, як користувач через інтерфейс формує запит POST із параметрами запису (дата, час, лікар, користувач), як запит проходить через middleware авторизації, де перевіряється JWT-токен і визначається поточний користувач, як контролер виконує бізнес-перевірки (існування користувача, прав лікаря, відсутність конфлікту в розкладі), звертається до ORM для створення нового запису в базі даних та отримує результат операції. У разі успіху контролер повертає відповідь 201 Created із JSON-описом створеного запису на огляд, а у випадку помилки — структуровану відповідь із кодом 400, 401, 403 або 409, залежно від типу порушення (некоректні дані, відсутність доступу, конфлікт у розкладі).


ДОДАТОК А
Посилання на відеозапис
https://youtu.be/gyLAExcLqzw
