Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії



Звіт
з лабораторної роботи №2
з дисципліни «Аналіз та рефакторінг коду»






Виконав:                                                                                             Перевірив:
ст. гр. ПЗПІ 23-7                                                                        Дашенков Д. С.
Максименко Мрако                                   
Віталійович                          
                                                                       









Харків 2025
1 БУДОВА ПРОГРАМНОЇ СИСТЕМИ
1.1 Архітектурні рішення для серверної частини системи
Програмна система аналізу та догляду за шкірою реалізується у вигляді клієнт–серверного застосунку, де серверна частина відповідає за зберігання даних, бізнес-логіку та роботу з базою даних, а клієнти (веб-інтерфейс, мобільний застосунок, у перспективі – IoT-пристрої) звертаються до неї через REST API.
Серверна частина побудована на платформі Node.js з використанням фреймворку Express. Такий підхід дозволяє швидко організувати обробку HTTP-запитів, розділити код на маршрути й контролери та забезпечити масштабованість у майбутньому. Вся функціональність згрупована навколо доменних сутностей системи: користувачів, описів шкіри, аналізів, курсів лікування та записів умов аналізу.
Для зберігання даних використовується реляційна СУБД (наприклад, PostgreSQL або SQLite). Структура бази даних спроєктована на основі ER-діаграми та включає таблиці User, Skin, Analysis, Treatment, SkinAnalysisRecord. Зв’язки між ними організовані через зовнішні ключі, що забезпечує цілісність даних: кожен запис про шкіру належить певному користувачу, кожен аналіз прив’язаний до конкретної шкіри, а записи умов аналізу пов’язані з певним аналізом.
Доступ до сервера здійснюється через REST API, де дані передаються в форматі JSON. Для захисту API застосовується авторизація за токеном (наприклад, JWT) та middleware, яке перевіряє, чи є користувач авторизованим та чи має він розширені права (косметолог/адміністратор). При цьому окремого «адмінського» API з префіксом /api/admin не виділяється – усі маршрути об’єднані під загальним префіксом /api, а розмежування прав реалізовано через прапорець is_admin у моделі користувача.
Клієнтська частина може бути реалізована як веб-інтерфейс (наприклад, на React або чистому JavaScript), що дозволяє користувачу переглядати призначені курси лікування, власну історію стану шкіри та результати аналізів. У перспективі система може бути доповнена мобільним клієнтом та IoT-клієнтом, який автоматично надсилатиме результати апаратних вимірювань шкіри на сервер.
1.2 Моделі, що використовуються в системі
Архітектура серверної частини ґрунтується на наборі доменних моделей, які відображають основні сутності предметної області аналізу та догляду за шкірою.
Модель User (Користувач)
Центральна сутність, що представляє людину, для якої ведеться облік стану шкіри та лікування. Поля моделі включають ідентифікатор, ім’я, email (унікальний логін), пароль (зберігається у зашифрованому вигляді) та логічний прапорець is_admin, який позначає користувачів із розширеними правами (косметолог/адміністратор). Один користувач може мати кілька станів шкіри та кілька курсів лікування.
Модель Skin (Шкіра)
Описує конкретний стан шкіри користувача. Зберігає тип шкіри (жирна, суха, комбінована, нормальна тощо) та текстовий опис (наявні проблеми, чутливість, висипання). Кожен запис Skin пов’язаний із одним користувачем (User), але користувач може мати кілька різних описів стану (наприклад, «до лікування» і «після курсу лікування»).
Модель Analysis (Аналіз)
Відповідає за зберігання результатів аналізів шкіри. Містить посилання на конкретний стан шкіри (skin_id), тип аналізу (візуальний огляд, апаратний аналіз, тест на вологість тощо) та текстовий результат. Аналізи дозволяють відстежувати зміни стану шкіри в різні моменти часу.
Модель SkinAnalysisRecord (Запис аналізу шкіри)
Допоміжна модель, що деталізує умови проведення аналізу: стан шкіри під час обстеження, дата проведення, контекст (наприклад, «після вмивання», «після тижня лікування»). Кожен запис прив’язаний до певного аналізу (Analysis), а сам аналіз може мати кілька таких записів.
Модель Treatment (Лікування)
Описує курс лікування або догляду, призначений користувачу. Містить тип лікування (наприклад, «курс крему з ретинолом», «апаратна терапія», «комбінований догляд»), дату початку та завершення. Через цю модель фіксується, які саме дії були виконані над шкірою та у який період, що дозволяє пов’язувати зміни стану шкіри з конкретними курсами лікування.
У сукупності ці моделі формують цілісну структуру, у центрі якої знаходиться користувач, його шкіра, аналізи та лікування. Такий підхід дозволяє будувати аналітику, оцінювати ефективність різних підходів до догляду та розширювати систему в майбутньому (наприклад, додаванням нових типів аналізів або рекомендаційних модулів).
2 UML ДІАГРАМА ПРЕЦЕДЕНТІВ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ
2.1 UML діаграма
UML-діаграма прецедентів відображає основні сценарії взаємодії користувачів із програмною системою аналізу та догляду за шкірою. На діаграмі (рисунок 2.1) зображено два ключові актори:
• Користувач – людина, для якої ведеться облік стану шкіри;
• Адміністратор/Косметолог – спеціаліст, що створює аналізи шкіри, призначає курси лікування та керує обліковими записами.

Рис. 2.1 – UML-діаграма прецедентів програмної системи аналізу та догляду за шкірою
UML-діаграма побудована у вигляді стандартної use case diagram, де всередині системної межі розташовані прецеденти, а актори з’єднані з ними асоціаціями. Додатково використано відношення <<include>> для позначення загальних сценаріїв (перегляд історії стану шкіри та результатів аналізів), які повторно використовуються кількома більш складними прецедентами.
2.2 Опис діаграми
Актор «Користувач»
Користувач є центральною фігурою системи, адже саме для нього збираються дані про стан шкіри та ефективність лікування. На діаграмі для нього передбачено такі основні прецеденти:
• «Переглянути призначені курси лікування» – дозволяє користувачу побачити активні та завершені курси Treatment, призначені косметологом.
• «Переглянути особистий звіт про стан шкіри» – формує узагальнену інформацію про зміни стану шкіри за певний період, включаючи проведені аналізи та курси лікування. Цей прецедент <<include>> використовує загальні сценарії:
o «Переглянути результати аналізів»;
o «Переглянути історію стану шкіри».
• «Описати стан шкіри користувача» – дає можливість користувачу оновити опис власної шкіри (тип, проблеми, суб’єктивні відчуття), що відображається в сутності Skin.
Таким чином, користувач взаємодіє із системою переважно в режимі перегляду та оновлення інформації про свою шкіру.
Актор «Адміністратор/Косметолог»
Адміністратор/косметолог має розширені права доступу та виконує професійні дії:
• «Створити запис користувача» – реєструє нового користувача в системі (створює запис User).
• «Створити аналіз шкіри користувача» – на основі огляду або апаратної діагностики створює новий запис Analysis для обраного стану шкіри.
• «Переглянути історію аналізів користувача» – отримує повну картину проведених аналізів, використовуючи загальний прецедент «Переглянути результати аналізів».
• «Рекомендувати курс лікування/догляду» – на основі аналізів та поточного стану шкіри призначає новий курс Treatment. Цей прецедент <<include>> використовує базову операцію «Створити курс лікування/догляду».
• «Створити курс лікування/догляду» – створює запис Treatment із зазначенням типу лікування, дат початку та завершення.
• «Керувати користувачами» – включає редагування даних користувачів, блокування або видалення записів за потреби.
Усі ці дії реалізуються на сервері через REST API: косметолог викликає відповідні ендпоінти для створення, перегляду та оновлення даних, а система зберігає їх у базі.
3 ER-ДІАГРАМА
3.1 Опис ER-діаграми бази даних
ER-діаграма відображає логічну структуру бази даних програмної системи аналізу та догляду за шкірою. На ній зображені основні сутності та зв’язки між ними:
Рис. 3.1 – ER-діаграма бази даних програмної системи аналізу та догляду за шкірою
• User – зберігає інформацію про користувачів системи (ім’я, email, пароль, прапорець is_admin).
• Skin – описує стани шкіри користувачів та пов’язана з User через зв’язок «один-до-багатьох» (один користувач може мати кілька станів шкіри).
• Analysis – містить результати аналізів і пов’язана з Skin також зв’язком «один-до-багатьох».
• SkinAnalysisRecord – деталізує умови проведення аналізів та дату, пов’язана з Analysis.
• Treatment – зберігає інформацію про курси лікування й догляду для користувачів, пов’язана з User.
Центральною сутністю є User, від якої відходять два основні ланцюжки даних:
1. User → Skin → Analysis → SkinAnalysisRecord
Цей ланцюжок описує історію стану шкіри та проведених аналізів. Кожен користувач має один або кілька описів шкіри, до кожного стану можуть виконуватися різні аналізи, а для кожного аналізу зберігаються детальні записи умов його проведення.
2. User → Treatment
Тут фіксуються всі призначені курси лікування або догляду для користувача. Це дозволяє пов’язувати зміни стану шкіри з конкретними лікувальними впливами.
Узагальнюючи, ER-діаграма описує добре структуровану модель даних, у якій користувач, його шкіра, аналізи та лікування утворюють логічний ланцюг. Така модель слугує надійним фундаментом для реалізації серверної частини та аналітичних можливостей системи.
4 БАЗА ДАНИХ ПРОГРАМНОЇ СИСТЕМИ
4.1 Таблиці бази даних
База даних програмної системи побудована на основі сутностей, відображених на ER-діаграмі, і включає такі таблиці:
Таблиця User
Містить інформацію про всіх користувачів системи:
ідентифікатор, ім’я, email, зашифрований пароль та логічний прапорець is_admin. Ця таблиця є точкою входу в модель даних: всі інші таблиці або безпосередньо, або опосередковано пов’язані з конкретним користувачем. Через неї реалізується створення облікових записів та розмежування прав доступу.
Таблиця Skin
Зберігає описи стану шкіри: тип (жирна, суха, нормальна тощо) та текстовий опис. Має зовнішній ключ user_id, що вказує на користувача, якому належить цей стан. Ця таблиця використовується для формування особистого звіту про стан шкіри та для прив’язки аналізів.
Таблиця Analysis
Містить записи про проведені аналізи. Для кожного аналізу зберігається посилання на стан шкіри (skin_id), тип аналізу та текстовий результат. На основі цієї таблиці користувач і косметолог можуть переглядати історію аналізів, а також оцінювати ефективність лікування.
Таблиця SkinAnalysisRecord
Призначена для детального опису умов конкретного аналізу: стан шкіри під час проведення, дата, контекст. Має зовнішній ключ analysis_id, тому кожен запис однозначно пов’язаний із конкретним аналізом. Ці дані використовуються для побудови точнішої картини змін шкіри з часом.
Таблиця Treatment
Зберігає інформацію про курси лікування та догляду: тип лікування, дату початку та завершення, а також посилання на користувача (user_id). Завдяки цій таблиці система може показувати користувачу призначені курси, а косметологу – аналізувати, як ті чи інші схеми вплинули на стан шкіри.
У сукупності таблиці бази даних реалізують логічну модель предметної області:
користувач → його шкіра → аналізи та записи умов → призначені курси лікування.
5 ДІАГРАМА СТРУКТУРИ БД
5.1 Діаграма бази даних
На діаграмі структури бази даних (рисунок 5.1) зображено фізичну схему таблиць із зазначенням полів, типів даних та зовнішніх ключів. Таблиці розташовані таким чином, щоб підкреслити їхню роль у загальній моделі:
• User займає центральне положення, адже від нього через зовнішні ключі user_id відходять таблиці Skin та Treatment. Це показує, що всі дані безпосередньо пов’язані з конкретним користувачем.
• Skin розташована поруч із User та пов’язана ланцюжком із таблицею Analysis, що відображає процес аналізу стану шкіри для кожного опису.
• Analysis у свою чергу пов’язана з SkinAnalysisRecord, яка деталізує кожен аналіз окремими записами умов та датою проведення.
• Treatment може бути зображена паралельно гілці аналізів, що підкреслює, що курси лікування логічно пов’язані з користувачем, але можуть аналізуватися разом із історією стану шкіри.
Такий вигляд схеми наочно демонструє, як саме пов’язуються між собою дані, отримані від користувача, косметолога та потенційних IoT-пристроїв. Діаграма дозволяє швидко зрозуміти, які таблиці є основними, а які – допоміжними, та полегшує подальше розширення структури бази.

Рис. 5.1 – Схема бази даних програмної системи аналізу та догляду за шкірою
6 РОЗРОБИТИ ФУНКЦІЇ РОБОТИ З БД
6.1 Методи доступу до БД
У системі доступ до бази даних реалізовано через окремий шар функцій/репозиторіїв, які інкапсулюють виконання SQL-запитів. Це дозволяє ізолювати бізнес-логіку від деталей реалізації БД та спрощує тестування.
Функції для таблиці User
Методи роботи з користувачами забезпечують:
• створення нового користувача (insert у таблицю User з перевіркою унікальності email);
• отримання користувача за ідентифікатором;
• оновлення профілю (ім’я, email, пароль);
• видалення користувача;
• отримання списку всіх користувачів (тільки для косметолога/адміністратора);
• перевірку логіна та пароля під час авторизації.
Функції для таблиці Skin
Для таблиці Skin реалізовано:
• створення опису стану шкіри для конкретного користувача;
• отримання списку станів шкіри користувача;
• оновлення опису та типу шкіри;
• видалення запису, якщо інформація стала неактуальною.
Функції для таблиці Analysis
• додавання нового аналізу для обраного запису Skin;
• отримання аналізу за ідентифікатором;
• отримання списку аналізів для певної шкіри або користувача;
• оновлення результату аналізу;
• видалення аналізу за потреби.
Функції для таблиці SkinAnalysisRecord
• створення запису про умови проведення аналізу (analysis_id, дата, опис стану шкіри);
• вибірка всіх записів для конкретного аналізу;
• оновлення існуючого запису;
• видалення запису.
Функції для таблиці Treatment
• створення нового курсу лікування (тип лікування, дати початку й завершення, user_id);
• отримання списку курсів лікування користувача;
• перегляд конкретного курсу за ідентифікатором;
• оновлення даних курсу (наприклад, продовження лікування);
• видалення курсу, що втратив актуальність.
Усі методи виконують стандартні операції CRUD через уніфікований механізм підключення до бази даних. Така організація коду дозволяє легко змінити СУБД або спосіб доступу (наприклад, перейти з «чистого» SQL на ORM) без суттєвих змін у бізнес-логіці.
7 РОЗРОБКА API ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ
7.1 Тип API, що буде використовуватися
Для взаємодії між клієнтською частиною та сервером використовується REST API. Дані передаються у форматі JSON через стандартні HTTP-методи (GET, POST, PUT, DELETE, PATCH). Усі ендпоінти мають спільний префікс /api.
Авторизація реалізується за допомогою токенів (наприклад, JWT). До конфіденційних маршрутів додається middleware authMiddleware, яке перевіряє наявність і валідність токена. Для операцій, що можуть виконувати лише косметологи/адміністратори, використовується додаткове middleware adminMiddleware, яке перевіряє прапорець is_admin у моделі користувача.
При цьому не використовується окремий «адмінський» маршрут /api/admin – усі запити проходять через загальний простір /api, а доступ обмежується на рівні middleware.
Нижче наведено основні контролери та ендпоінти API.
AuthController
Відповідає за створення користувачів і базову авторизацію.
• POST /api/register – реєстрація нового користувача.
Приймає у тілі запиту дані про ім’я, email і пароль; створює запис у таблиці User з is_admin = false.
• POST /api/login – вхід користувача в систему.
Перевіряє email і пароль, у разі успіху повертає токен авторизації та коротку інформацію про користувача.
UsersController
Працює з даними користувачів.
• GET /api/users/:id – отримати інформацію про конкретного користувача.
Вимагає authMiddleware; користувач може отримати свої дані, а користувач із прапорцем is_admin = true – дані будь-якого користувача.
• PUT /api/users/:id – оновити профіль користувача.
Доступно авторизованому користувачу для власного профілю або косметологу з розширеними правами.
• DELETE /api/users/:id – видалити користувача.
Доступно лише для користувачів з is_admin = true.
• GET /api/users – отримати список усіх користувачів.
Маршрут захищено adminMiddleware, тому його можуть викликати лише косметологи/адміністратори.
SkinController
Описує стан шкіри користувача (модель Skin).
• GET /api/skin/:id – отримати опис конкретного стану шкіри.
Доступно авторизованому користувачу (для власних записів) або адміністратору.
• GET /api/skin – отримати список станів шкіри.
Може повертати всі описи (для косметолога) або лише описи поточного користувача.
• POST /api/skin – створити новий опис стану шкіри.
Викликається при первинному огляді або коли користувач/косметолог фіксує новий стан шкіри.
• PUT /api/skin/:id – оновити існуючий опис стану шкіри.
• DELETE /api/skin/:id – видалити запис, що втратив актуальність.
Найчастіше такі дії виконуються користувачем щодо власних записів або косметологом з розширеними правами.
AnalysisController
Працює з аналізами шкіри (модель Analysis).
• GET /api/analysis/:id – отримати конкретний аналіз шкіри.
Вимагає авторизації; доступ дозволено власнику запису або адміністратору.
• GET /api/analysis – отримати список аналізів.
Може фільтруватися за користувачем, станом шкіри чи датою.
• POST /api/analysis – створити новий аналіз шкіри користувача.
Маршрут захищено adminMiddleware, оскільки проведення офіційного аналізу виконує косметолог/адміністратор.
• PUT /api/analysis/:id – оновити результат аналізу (наприклад, після уточнення діагнозу).
• DELETE /api/analysis/:id – видалити аналіз (при помилковому введенні або за рішенням спеціаліста).
SkinAnalysisRecordController
Оперує деталізованими записами умов аналізу (модель SkinAnalysisRecord).
• GET /api/record – отримати всі записи умов аналізу (для косметолога) або тільки по поточному користувачу.
• GET /api/record/:id – переглянути конкретний запис.
• POST /api/record – створити запис умов для певного аналізу (analysis_id, дата, опис стану шкіри).
Використовується косметологом під час або після проведення аналізу.
• PUT /api/record/:id – оновити запис (уточнити опис або дату).
• DELETE /api/record/:id – видалити запис.
TreatmentController
Відповідає за керування курсами лікування (модель Treatment).
• GET /api/treatment/:id – отримати інформацію про конкретний курс лікування.
Доступно авторизованому користувачу (для власних курсів) та косметологу.
• GET /api/treatment – отримати список курсів лікування.
Може повертати всі курси (для косметолога) або лише курси поточного користувача.
• POST /api/treatment – створити новий курс лікування/догляду для користувача.
Викликається косметологом після аналізу стану шкіри.
• PUT /api/treatment/:id – оновити інформацію про курс (змінити дати, скоригувати тип лікування).
• DELETE /api/treatment/:id – скасувати або видалити курс лікування, що не є актуальним.
Усі ендпоінти працюють з DTO-об’єктами, які відокремлюють зовнішній формат даних від внутрішньої структури таблиць. Це спрощує зміну схеми БД та підвищує безпеку, оскільки клієнт не має прямого доступу до внутрішніх ідентифікаторів чи службових полів.
8 СПЕЦИФІКАЦІЯ РОЗРОБЛЕНОГО API
У цьому розділі наведено детальний опис основних ендпоінтів API, а також приклади запитів і відповідей у форматі JSON.
Для взаємодії використовується REST API, дані передаються у форматі JSON. Частина ендпоінтів потребує авторизації та перевірки прав доступу (прапорець is_admin у записі користувача).
8.1 UserController
Призначення: реєстрація та авторизація користувачів, отримання та оновлення інформації про них, видалення записів.

POST /api/register — реєстрація нового користувача.
Запит:
{
  "name": "Іван Іванов",
  "email": "user@example.com",
  "password": "string"
}
Відповідь (201 Created – створений користувач без пароля):
{
  "id": 1,
  "name": "Іван Іванов",
  "email": "user@example.com",
  "is_admin": false
}

POST /api/login — авторизація користувача.
Запит:
{
  "email": "user@example.com",
  "password": "string"
}
Відповідь (200 Успішний вхід, на клієнт встановлюється cookie access з JWT-токеном):
{
  "message": "Login successful"
}

GET /api/users/{id} — отримати інформацію про конкретного користувача.
Запит (без тіла, вимагає авторизації):
GET /api/users/1
Відповідь (200 OK):
{
  "id": 1,
  "name": "Іван Іванов",
  "email": "user@example.com",
  "is_admin": false
}

GET /api/users — отримати список усіх користувачів (для користувачів з is_admin = true).
Запит:
GET /api/users
Відповідь (200 OK – масив користувачів без паролів):
[
  {
    "id": 1,
    "name": "Іван Іванов",
    "email": "user@example.com",
    "is_admin": false
  },
  {
    "id": 2,
    "name": "Марія Петренко",
    "email": "maria@example.com",
    "is_admin": true
  }
]

PUT /api/users/{id} — оновити дані користувача.
Запит:
{
  "name": "Іван Петров",
  "email": "newmail@example.com",
  "password": "newPassword123"
}
Відповідь (200 OK – оновлений користувач без пароля):
{
  "id": 1,
  "name": "Іван Петров",
  "email": "newmail@example.com",
  "is_admin": false
}

DELETE /api/users/{id} — видалити користувача.
Запит:
DELETE /api/users/1
Відповідь (204 No Content – тіло відповіді відсутнє).
GET /api/users/me — отримати поточного користувача за токеном.
Запит (тіла немає, токен передається в cookie access):
GET /api/users/me
Відповідь (200 OK – дані користувача без пароля):
{
  "id": 1,
  "name": "Іван Іванов",
  "email": "user@example.com",
  "is_admin": false
}
Якщо користувача за токеном не знайдено:
{
  "error": "User not found"
}

8.2 SkinController
Призначення: створення, перегляд, оновлення та видалення описів стану шкіри користувачів.

POST /api/skin — створити опис стану шкіри.
Запит:
{
  "type": "жирна",
  "description": "Схильна до висипань у зоні T",
  "user_id": 1
}
Відповідь (201 Created):
{
  "id": 1,
  "type": "жирна",
  "description": "Схильна до висипань у зоні T",
  "user_id": 1
}

GET /api/skin/{id} — отримати опис конкретного стану шкіри.
Запит:
GET /api/skin/1
Відповідь (200 OK):
{
  "id": 1,
  "type": "жирна",
  "description": "Схильна до висипань у зоні T",
  "user_id": 1
}

GET /api/skin — отримати список описів стану шкіри.
Запит:
GET /api/skin
Відповідь (200 OK – масив записів Skin):
[
  {
    "id": 1,
    "type": "жирна",
    "description": "Схильна до висипань у зоні T",
    "user_id": 1
  },
  {
    "id": 2,
    "type": "суха",
    "description": "Сухість і лущення в області щік",
    "user_id": 2
  }
]

PUT /api/skin/{id} — оновити опис стану шкіри.
Запит:
{
  "type": "комбінована",
  "description": "Жирна в зоні T, нормальна на щоках"
}
Відповідь (200 OK):
{
  "id": 1,
  "type": "комбінована",
  "description": "Жирна в зоні T, нормальна на щоках",
  "user_id": 1
}

DELETE /api/skin/{id} — видалити запис стану шкіри.
Запит:
DELETE /api/skin/1
Відповідь (204 No Content).

8.3 AnalysisController
Призначення: створення та керування записами аналізів шкіри.

POST /api/analysis — створити новий аналіз шкіри.
Запит:
{
  "analysis_type": "апаратний аналіз вологості",
  "result": "Рівень вологості нижче норми у зоні щік",
  "skin_id": 1
}
Відповідь (201 Created):
{
  "id": 1,
  "analysis_type": "апаратний аналіз вологості",
  "result": "Рівень вологості нижче норми у зоні щік",
  "skin_id": 1
}

GET /api/analysis/{id} — отримати аналіз за ідентифікатором.
Запит:
GET /api/analysis/1
Відповідь (200 OK):
{
  "id": 1,
  "analysis_type": "апаратний аналіз вологості",
  "result": "Рівень вологості нижче норми у зоні щік",
  "skin_id": 1
}

GET /api/analysis — отримати список усіх аналізів.
Запит:
GET /api/analysis
Відповідь (200 OK – масив аналізів):
[
  {
    "id": 1,
    "analysis_type": "апаратний аналіз вологості",
    "result": "Рівень вологості нижче норми у зоні щік",
    "skin_id": 1
  },
  {
    "id": 2,
    "analysis_type": "візуальний огляд",
    "result": "Легка еритема у зоні носа",
    "skin_id": 1
  }
]

PUT /api/analysis/{id} — оновити дані аналізу.
Запит:
{
  "analysis_type": "апаратний аналіз",
  "result": "Показники в межах норми"
}
Відповідь (200 OK):
{
  "id": 1,
  "analysis_type": "апаратний аналіз",
  "result": "Показники в межах норми",
  "skin_id": 1
}

DELETE /api/analysis/{id} — видалити аналіз.
Запит:
DELETE /api/analysis/1
Відповідь (204 No Content).

8.4 SkinAnalysisRecordController
Призначення: фіксація умов проведення аналізів шкіри та дат їх виконання.

POST /api/record — створити запис умов аналізу шкіри.
Запит:
{
  "skin_condition": "Після тижня використання зволожуючого крему",
  "date": "2025-05-20",
  "analysis_id": 1
}
Відповідь (201 Created):
{
  "id": 1,
  "skin_condition": "Після тижня використання зволожуючого крему",
  "date": "2025-05-20",
  "analysis_id": 1
}

GET /api/record/{id} — отримати запис аналізу шкіри за ідентифікатором.
Запит:
GET /api/record/1
Відповідь (200 OK):
{
  "id": 1,
  "skin_condition": "Після тижня використання зволожуючого крему",
  "date": "2025-05-20",
  "analysis_id": 1
}

GET /api/record — отримати список записів аналізів шкіри.
Запит:
GET /api/record
Відповідь (200 OK – масив записів):
[
  {
    "id": 1,
    "skin_condition": "Після тижня використання зволожуючого крему",
    "date": "2025-05-20",
    "analysis_id": 1
  },
  {
    "id": 2,
    "skin_condition": "Перед початком лікування",
    "date": "2025-05-10",
    "analysis_id": 1
  }
]

PUT /api/record/{id} — оновити запис аналізу шкіри.
Запит:
{
  "skin_condition": "Після двох тижнів лікування",
  "date": "2025-05-27"
}
Відповідь (200 OK):
{
  "id": 1,
  "skin_condition": "Після двох тижнів лікування",
  "date": "2025-05-27",
  "analysis_id": 1
}

DELETE /api/record/{id} — видалити запис аналізу шкіри.
Запит:
DELETE /api/record/1
Відповідь (204 No Content).

8.5 TreatmentController
Призначення: створення та керування курсами лікування та догляду за шкірою.

POST /api/treatment — створити курс лікування/догляду.
Запит:
{
  "treatment_type": "Курс зволожуючого крему на ніч",
  "start_date": "2025-05-01",
  "end_date": "2025-05-31",
  "user_id": 1
}
Відповідь (201 Created):
{
  "id": 1,
  "treatment_type": "Курс зволожуючого крему на ніч",
  "start_date": "2025-05-01",
  "end_date": "2025-05-31",
  "user_id": 1
}

GET /api/treatment/{id} — отримати конкретний курс лікування.
Запит:
GET /api/treatment/1
Відповідь (200 OK):
{
  "id": 1,
  "treatment_type": "Курс зволожуючого крему на ніч",
  "start_date": "2025-05-01",
  "end_date": "2025-05-31",
  "user_id": 1
}

GET /api/treatment — отримати список курсів лікування.
Запит:
GET /api/treatment
Відповідь (200 OK – масив курсів лікування):
[
  {
    "id": 1,
    "treatment_type": "Курс зволожуючого крему на ніч",
    "start_date": "2025-05-01",
    "end_date": "2025-05-31",
    "user_id": 1
  },
  {
    "id": 2,
    "treatment_type": "Курс засобів проти акне",
    "start_date": "2025-06-01",
    "end_date": "2025-06-30",
    "user_id": 1
  }
]

PUT /api/treatment/{id} — оновити інформацію про курс лікування.
Запит:
{
  "treatment_type": "Курс зволожуючого крему та сироватки",
  "end_date": "2025-06-07"
}
Відповідь (200 OK):
{
  "id": 1,
  "treatment_type": "Курс зволожуючого крему та сироватки",
  "start_date": "2025-05-01",
  "end_date": "2025-06-07",
  "user_id": 1
}

DELETE /api/treatment/{id} — видалити курс лікування.
Запит:
DELETE /api/treatment/1
Відповідь (204 No Content).
9 ПЕРЕВІРКА РОБОТИ СТВОРЕНОГО КОДУ
9.1 Тестування розроблених функцій
Для перевірки роботи серверної частини програмної системи аналізу та догляду за шкірою було використано інструмент Postman. За його допомогою виконувалися тестові HTTP-запити до розроблених ендпоінтів, що дозволило перевірити коректність обробки вхідних даних, повернення відповідних кодів стану та структуру відповідей API.

На рисунку 9.1 показано тестування методу реєстрації нового користувача. Виконується запит POST http://localhost:3000/api/register з тілом у форматі JSON, яке містить поля name, email та password. У разі коректно заповнених даних сервер повертає код 201 Created і об’єкт створеного користувача з полями id, name, email, а також прапорцем is_admin, який за замовчуванням має значення false. Таким чином підтверджується, що механізм реєстрації коректно створює облікові записи з роллю звичайного користувача без привілеїв адміністратора.

Рис. 9.1 – Тестування реєстрації користувача (POST /api/register)
На рисунку 9.2 наведено результат перевірки ендпоінта отримання поточного користувача за токеном. Виконується запит GET http://localhost:3000/api/users/me. Тіло запиту відсутнє, ідентифікація користувача здійснюється за cookie з JWT-токеном, який був виданий під час реєстрації/авторизації. У відповіді з кодом 200 OK повертається JSON-об’єкт з полями id, name, email, is_admin, що підтверджує коректну роботу механізму аутентифікації та вилучення профілю поточного користувача. У разі відсутності валідного токена очікується код 401 Unauthorized.

Рис. 9.2 – Отримання поточного користувача (GET /api/users/me)
На рисунку 9.3 продемонстровано тестування створення запису про стан шкіри. Для цього виконується запит POST http://localhost:3000/api/skin з тілом у форматі JSON, що містить поля type (тип шкіри) та description (текстовий опис стану), а також user_id, який визначає, якому користувачу належить цей запис. У разі успішного створення запису сервер повертає код 201 Created і JSON-об’єкт з полями id, type, description, user_id. Це підтверджує, що бізнес-логіка правильно пов’язує стани шкіри з конкретними користувачами й зберігає відповідні дані в базі.


Рис. 9.3 – Створення опису стану шкіри (POST /api/skin)
На рисунку 9.4 показано тестування ендпоінта отримання списку всіх записів про стан шкіри. Виконується запит GET http://localhost:3000/api/skin без параметрів. У відповідь сервер повертає код 200 OK і масив JSON-об’єктів, кожен з яких містить id, type, description та user_id. Це підтверджує коректну роботу методу читання даних, а також те, що щойно створений у попередньому кроці запис доступний для подальшого перегляду в системі.

Рис. 9.4 – Отримання списку записів стану шкіри (GET /api/skin)
На рисунку 9.5 наведено результат тестування видалення запису про стан шкіри. Для цього використовується запит DELETE http://localhost:3000/api/skin/1, де 1 – ідентифікатор запису, який потрібно видалити. У разі успішного виконання сервер повертає код 204 No Content без тіла відповіді, що відповідає REST-практиці для операцій видалення. Після цього при подальшому запиті списку станів шкіри даний запис більше не повертається, що підтверджує коректну реалізацію операції видалення та узгодженість даних у базі.

Рис. 9.5 – Видалення запису стану шкіри (DELETE /api/skin/{id})
Таким чином, за допомогою інструмента Postman було проведено інтеграційне тестування основних функцій API програмної системи аналізу та догляду за шкірою: реєстрації користувачів, отримання інформації про поточного користувача, створення, перегляду та видалення описів стану шкіри. Отримані результати підтвердили коректність реалізації розроблених ендпоінтів, відповідність повернених HTTP-кодів очікуваним та правильність структури JSON-відповідей.


ДОДАТОК А
Посилання на відео:
https://youtu.be/lxUrC_BbiJo
